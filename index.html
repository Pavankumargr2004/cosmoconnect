<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100%25><text y=%22.9em%22 font-size=%2290%22>ü™ê</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CosmoConnect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <style>
      body {
        font-family: 'Orbitron', sans-serif;
        background-color: #0a0a2a; /* A darker space blue */
        color: #e0e0e0;
      }
      
      #space-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        display: block;
      }

      /* Custom scrollbar hiding utility */
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
      }

      .hero-sphere {
        background: radial-gradient(circle at 30% 30%, #444, #111);
        box-shadow: 0 0 50px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.8);
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.21.0",
    "recharts": "https://aistudiocdn.com/recharts@^2.12.7",
    "tone": "https://aistudiocdn.com/tone@^15.0.4",
    "framer-motion": "https://aistudiocdn.com/framer-motion@^11.3.19"
  }
}
</script>
<script>
    tailwind.config = {
      theme: {
        extend: {
          animation: {
            'spin-slow': 'spin 20s linear infinite',
            'pulse-glow': 'pulse-glow 4s ease-in-out infinite',
            'fade-in': 'fade-in 0.5s ease-out forwards',
            'fade-in-fast': 'fade-in 0.3s ease-out forwards',
            'zoom-in': 'zoom-in 0.5s ease-out forwards',
            'blink-cursor': 'blink-cursor 0.8s infinite',
            'fade-in-out': 'fade-in-out 6s ease-in-out forwards',
            'danger-pulse': 'danger-pulse 0.4s ease-in-out',
            'pulse-buddy': 'pulse-buddy 2s ease-in-out infinite',
            'swirl-slow': 'spin 10s linear infinite',
            'swirl-medium': 'spin 8s linear infinite reverse',
            'swirl-fast': 'spin 2s linear infinite',
            'aurora-glow': 'aurora-glow 20s ease-in-out infinite',
            'rotate-globe': 'rotate-globe 40s linear infinite',
          },
          keyframes: {
            'pulse-glow': {
              '0%, 100%': {
                transform: 'scale(1)',
                filter: 'drop-shadow(0 0 2.5rem #f59e0b)' /* Warm yellow glow */
              },
              '50%': {
                transform: 'scale(1.05)', /* Slightly larger pulse */
                filter: 'drop-shadow(0 0 4rem #ef4444)' /* Intense reddish-orange glow */
              },
            },
            'fade-in': {
              '0%': { opacity: '0', transform: 'translateY(10px)' },
              '100%': { opacity: '1', transform: 'translateY(0)' },
            },
             'zoom-in': {
              '0%': { opacity: '0', transform: 'scale(0.95)' },
              '100%': { opacity: '1', transform: 'scale(1)' },
            },
            'blink-cursor': {
              '50%': { opacity: '0' }
            },
            'fade-in-out': {
              '0%, 100%': { opacity: '0', transform: 'translateY(20px) scale(0.95)' },
              '10%, 90%': { opacity: '1', transform: 'translateY(0) scale(1)' },
            },
            'pulse-buddy': {
              '0%, 100%': {
                transform: 'scale(1)',
                boxShadow: '0 0 1.5rem rgba(103, 232, 249, 0.5), 0 0 0 0 rgba(167, 139, 250, 0.7)'
              },
              '50%': {
                transform: 'scale(1.1)',
                boxShadow: '0 0 2.5rem rgba(103, 232, 249, 0.8), 0 0 0 15px rgba(167, 139, 250, 0)'
              },
            },
            'danger-pulse': {
              '0%, 100%': {
                transform: 'translate(0, 0)',
                boxShadow: 'inset 0 0 0 0 rgba(220, 38, 38, 0)',
              },
              '25%': { transform: 'translate(-3px, 2px)' },
              '50%': {
                boxShadow: 'inset 0 0 80px 30px rgba(220, 38, 38, 0.4)',
                transform: 'translate(3px, -2px)',
              },
              '75%': { transform: 'translate(-2px, -3px)' },
            },
            'aurora-glow': {
              '0%': { backgroundPosition: '0% 50%' },
              '50%': { backgroundPosition: '100% 50%' },
              '100%': { backgroundPosition: '0% 50%' },
            },
            'rotate-globe': {
              '0%': { backgroundPosition: '0% 50%' },
              '100%': { backgroundPosition: '200% 50%' },
            },
          }
        }
      }
    }
  </script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="no-scrollbar">
    <canvas id="space-background"></canvas>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
    <script>
      /* Custom A-Frame component for handling clicks/taps */
      AFRAME.registerComponent('click-handler', {
        init: function () {
          this.el.addEventListener('click', (evt) => {
            // Emit a custom event that other components can listen to
            this.el.emit('tap', null, false);
          });
        }
      });
      
      /* Custom A-Frame component for a simple particle burst effect */
      AFRAME.registerComponent('sparkle-burst', {
        init: function () {
            this.handleTap = this.handleTap.bind(this);
            this.el.addEventListener('tap', this.handleTap);
        },
        remove: function() {
            this.el.removeEventListener('tap', this.handleTap);
        },
        handleTap: function () {
            const count = 60; // Even more particles
            const duration = 1400; // A bit longer
            const colors = ['#FFD700', '#FFA500', '#f472b6', '#ff4500']; // Gold, Orange, Pink, Orange-Red
            const parentEl = this.el;
            
            const worldPosition = new THREE.Vector3();
            parentEl.object3D.getWorldPosition(worldPosition);

            for (let i = 0; i < count; i++) {
                const sparkle = document.createElement('a-sphere');
                parentEl.sceneEl.appendChild(sparkle);

                sparkle.setAttribute('position', worldPosition);
                
                const destination = {
                    x: worldPosition.x + (Math.random() - 0.5) * 2.5, // Spread farther
                    y: worldPosition.y + (Math.random() - 0.5) * 2.5,
                    z: worldPosition.z + (Math.random() - 0.5) * 2.5
                };
                
                sparkle.setAttribute('radius', Math.random() * 0.07 + 0.02); // Slightly bigger
                sparkle.setAttribute('color', colors[Math.floor(Math.random() * colors.length)]);
                sparkle.setAttribute('material', 'shader: flat; opacity: 1;');

                sparkle.setAttribute('animation', {
                    property: 'position',
                    to: `${destination.x} ${destination.y} ${destination.z}`,
                    dur: duration,
                    easing: 'easeOutQuad'
                });
                sparkle.setAttribute('animation__fade', {
                    property: 'material.opacity',
                    to: 0,
                    dur: duration,
                    easing: 'easeInQuad'
                });

                setTimeout(() => {
                    if (sparkle.parentNode) {
                        sparkle.parentNode.removeChild(sparkle);
                    }
                }, duration);
            }
        }
      });
    </script>
    <script>
      /* Custom A-Frame component for aurora effect */
      AFRAME.registerComponent('aurora-particles', {
        schema: {
          count: {type: 'number', default: 500},
          color: {type: 'color', default: '#a78bfa'},
          size: {type: 'number', default: 0.2},
          speed: {type: 'number', default: 0.001}
        },

        init: function () {
          const el = this.el;
          const data = this.data;
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(data.count * 3);
          this.velocities = [];

          for (let i = 0; i < data.count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = Math.random() * 5;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2 - 4;
            
            this.velocities.push({
                y: Math.random() * data.speed,
                yOffset: Math.random() * Math.PI, // For vertical acceleration
                xOffset: Math.random() * Math.PI * 2, // For swirling x
                zOffset: Math.random() * Math.PI * 2  // For swirling z
            });
          }

          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          
          const material = new THREE.PointsMaterial({
            color: new THREE.Color(data.color),
            size: data.size,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.7,
            depthWrite: false
          });

          this.particles = new THREE.Points(geometry, material);
          el.setObject3D('aurora-particles', this.particles);
        },

        tick: function (time, timeDelta) {
          if (!this.particles) return;
          
          const positions = this.particles.geometry.attributes.position.array;
          const speed = this.data.speed;

          for (let i = 0; i < this.data.count; i++) {
            const i3 = i * 3;
            const vel = this.velocities[i];
            
            // More dynamic, swirling motion
            const timeFactor = time * 0.001;
            positions[i3] += Math.sin(timeFactor + vel.xOffset) * 0.02;
            positions[i3 + 2] += Math.cos(timeFactor * 0.8 + vel.zOffset) * 0.015;
            
            // Vertical drift
            positions[i3 + 1] += vel.y * (timeDelta / 16); // normalize speed
            
            // More pronounced acceleration changes to make it feel more "alive"
            vel.y += Math.sin(time * 0.0002 + vel.yOffset) * 0.00008;

            // Reset particle when it goes off-screen
            if (positions[i3 + 1] > 5) {
                positions[i3] = (Math.random() - 0.5) * 10;
                positions[i3 + 1] = -1; // Start from below
                positions[i3 + 2] = (Math.random() - 0.5) * 2 - 4;
                vel.y = Math.random() * this.data.speed; // Reset vertical speed
            }
          }
          
          this.particles.geometry.attributes.position.needsUpdate = true;
        }
      });
    </script>
     <script>
      /* Custom A-Frame component for sky parallax effect */
      AFRAME.registerComponent('parallax-sky', {
        schema: {
          factor: {type: 'number', default: 0.1}
        },
        init: function () {
          this.camera = null;
        },
        tick: function () {
          if (!this.camera) {
            if (this.el.sceneEl && this.el.sceneEl.camera && this.el.sceneEl.camera.el) {
              this.camera = this.el.sceneEl.camera.el;
            } else {
              return; // Camera not ready yet, try again next tick
            }
          }
          const cameraRot = this.camera.object3D.rotation;
          const factor = this.data.factor;
          
          this.el.object3D.rotation.y = -cameraRot.y * factor;
          this.el.object3D.rotation.x = -cameraRot.x * factor;
        }
      });
    </script>
    <script>
      /* Advanced 3D Starfield Background */
      const canvas = document.getElementById('space-background');
      const ctx = canvas.getContext('2d');

      let width, height;
      let stars = [];
      let shootingStars = [];
      let sparkles = [];
      let mouse = { x: 0, y: 0 };

      const STAR_COUNT = 500;
      const SHOOTING_STAR_COUNT = 2;

      class Sparkle {
          constructor(x, y) {
              this.x = x;
              this.y = y;
              this.vx = (Math.random() - 0.5) * 3;
              this.vy = (Math.random() - 0.5) * 3;
              this.alpha = 1;
              this.radius = Math.random() * 2 + 1;
              this.life = 60; // life in frames
          }

          update() {
              this.x += this.vx;
              this.y += this.vy;
              this.alpha -= 1 / this.life;
          }
          
          isAlive() {
              return this.alpha > 0;
          }

          draw(ctx) {
              if (!this.isAlive()) return;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 220, ${this.alpha})`;
              ctx.fill();
          }
      }

      class Star {
          constructor() {
              this.x = Math.random() * 2 - 1; // -1 to 1
              this.y = Math.random() * 2 - 1; // -1 to 1
              this.z = Math.random() * 2;     // 0 to 2
              this.pz = this.z;
              this.radius = Math.random() * 1.2 + 0.3;
              this.alpha = 0.5 + Math.random() * 0.5;
          }

          update() {
              this.z -= 0.002; // Reduced speed
              if (this.z < 0) {
                  this.z = 2;
                  this.x = Math.random() * 2 - 1;
                  this.y = Math.random() * 2 - 1;
                  this.pz = this.z;
              }
          }

          draw(ctx, width, height, mouse) {
              const sx = (this.x / (this.z * 0.5)) * width / 2 + width / 2;
              const sy = (this.y / (this.z * 0.5)) * height / 2 + height / 2;
              
              const psx = (this.x / (this.pz * 0.5)) * width / 2 + width / 2;
              const psy = (this.y / (this.pz * 0.5)) * height / 2 + height / 2;

              let radius = this.radius / (this.z * 0.5);
              
              if (sx < 0 || sx > width || sy < 0 || sy > height) {
                  this.z = 2;
                  this.x = Math.random() * 2 - 1;
                  this.y = Math.random() * 2 - 1;
                  this.pz = this.z;
                  return;
              }

              const dist = Math.hypot(sx - mouse.x, sy - mouse.y);
              const hoverRadius = radius * 5 + 5; // Make hover area larger

              let finalAlpha = this.alpha;
              if (dist < hoverRadius) {
                  finalAlpha = Math.min(1, this.alpha + 0.5);
                  radius *= 1.5;
              }

              ctx.beginPath();
              ctx.arc(sx, sy, radius, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 255, 255, ${finalAlpha})`;
              ctx.fill();

              this.pz = this.z;
          }
      }

      class ShootingStar {
          constructor() {
              this.reset();
          }

          reset() {
              this.x = Math.random() * width;
              this.y = 0;
              this.len = (Math.random() * 80) + 10;
              this.speed = (Math.random() * 10) + 6;
              this.size = (Math.random() * 1) + 0.1;
              this.waitTime = new Date().getTime() + (Math.random() * 3000) + 500;
              this.active = false;
          }

          update() {
              if (this.active) {
                  this.x -= this.speed;
                  this.y += this.speed;
                  if (this.x < 0 || this.y >= height) {
                      this.reset();
                  }
              } else {
                  if (this.waitTime < new Date().getTime()) {
                      this.active = true;
                  }
              }
          }

          draw(ctx) {
              if (this.active) {
                  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                  ctx.lineWidth = this.size;
                  ctx.beginPath();
                  ctx.moveTo(this.x, this.y);
                  ctx.lineTo(this.x + this.len, this.y - this.len);
                  ctx.stroke();
              }
          }
      }

      function resize() {
          width = canvas.width = window.innerWidth;
          height = canvas.height = window.innerHeight;
          stars = Array.from({ length: STAR_COUNT }, () => new Star());
          shootingStars = Array.from({ length: SHOOTING_STAR_COUNT }, () => new ShootingStar());
      }
      
      function animate() {
          ctx.save();
          ctx.fillStyle = '#0a0a2a'; // Darker blue
          ctx.fillRect(0, 0, width, height);
          
          // Parallax effect
          const parallaxX = mouse.x / width - 0.5;
          const parallaxY = mouse.y / height - 0.5;
          ctx.translate(parallaxX * 50, parallaxY * 50);

          stars.forEach(star => {
              star.update();
              star.draw(ctx, width, height, mouse);
          });

          shootingStars.forEach(star => {
              star.update();
              star.draw(ctx);
          });
          
          sparkles.forEach(sparkle => {
              sparkle.update();
              sparkle.draw(ctx);
          });
          sparkles = sparkles.filter(s => s.isAlive());

          ctx.restore();
          requestAnimationFrame(animate);
      }
      
      window.addEventListener('resize', resize);
      window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      window.addEventListener('click', (e) => {
          const clickX = e.clientX;
          const clickY = e.clientY;
          for (const star of shootingStars) {
              if (!star.active) continue;
              
              const top = star.y - star.len;
              const bottom = star.y;
              const left = star.x;
              const right = star.x + star.len;

              if (clickX >= left && clickX <= right && clickY >= top && clickY <= bottom) {
                  for (let i = 0; i < 15; i++) {
                      sparkles.push(new Sparkle(clickX, clickY));
                  }
                  break; 
              }
          }
      });

      resize();
      animate();
    </script>
  </body>
</html>